From 451b4bb15010ec11a6015877e6259f8359479c68 Mon Sep 17 00:00:00 2001
From: Michael Haubenwallner <michael.haubenwallner@ssi-schaefer.com>
Date: Wed, 3 May 2017 16:32:41 +0200
Subject: [PATCH 1/6] testsuite.at: prefer diff --strip-trailing-cr

With respect to the usage of carriage return, output of test executables
depends on the compiler used rather than the host os.  For example,
while Cygwin does not use CR but LF only, overriding CC=cl.exe suddenly
gives CR+LF, causing various tests to fail for no good reason.
Instead, use --strip-trailing-cr flag (to GNU diff) if possible.

* tests/testsuite.at (PREPARE_TESTS): When diff supports the
--strip-trailing-cr flag, create wrapper function to add that flag and
define _fn_at_host_data_convert_line_endings function as noop.
(LT_AT_HOST_DATA): Use _fn_at_host_data_convert_line_endings function.
---
 tests/testsuite.at | 41 ++++++++++++++++++++++++++++++++++++++---
 1 file changed, 38 insertions(+), 3 deletions(-)

diff --git a/tests/testsuite.at b/tests/testsuite.at
index 5dbf266c..e7d9ec63 100644
--- a/tests/testsuite.at
+++ b/tests/testsuite.at
@@ -62,6 +62,43 @@ esac
 . "$abs_top_srcdir/build-aux/funclib.sh"
 . "$abs_top_srcdir/build-aux/extract-trace"
 
+# Setting CC without --host may lead to use of carriage return (CR) even
+# on hosts otherwise known to not use CR, like with CC=cl on Cygwin.
+# Fortunately, GNU diff provides the --strip-trailing-cr flag, which
+# allows us to prevent tests from failing just because of CR usage:
+# If diff supports --strip-trailing-cr, wrap it to add the flag when
+# at_test='diff -u' is used, and do not convert comparison files.
+# Otherwise, add CR to AT_HOST_DATA files for mingw host as before.
+case `diff --help 2>&1`,$host_os in # (
+*--strip-trailing-cr*,*)
+  lt_at_IFS=[$]IFS
+  IFS=:
+  for lt_at_p in [$]PATH; do
+    IFS=[$]lt_at_IFS
+    if test -x "[$]lt_at_p/diff"; then
+      eval 'diff() {
+	  if test x-u = "x[$]1"; then
+	    "'[$]lt_at_p'"/diff --strip-trailing-cr "[$]@"
+	  else
+	    "'[$]lt_at_p'"/diff "[$]@"
+	  fi
+	}'
+      _fn_at_host_data_convert_line_endings() { :; }
+      break
+    fi
+  done
+  IFS=[$]lt_at_IFS
+  $as_unset lt_at_p lt_at_IFS
+  ;;
+*,mingw*)
+  _fn_at_host_data_convert_line_endings() {
+    awk '{printf ("%s\r\n", [$]0);}' < "[$]1" > "[$]1.t" && mv -f "[$]1.t" "[$]1"
+  }
+  ;;
+*)
+  _fn_at_host_data_convert_line_endings() { :; }
+  ;;
+esac
 
 # Unset some MAKE... variables that may cause $MAKE to act like a
 # recursively invoked sub-make.  Any $MAKE invocation in a test is
@@ -274,9 +311,7 @@ AT_CHECK([test -z "$leftovers"])
 # Ensure correct line ending for expected output of host executables.
 m4_define([LT_AT_HOST_DATA],
 [AT_DATA([$1], [$2])
-case $host_os in mingw*)
-  awk '{printf ("%s\r\n", [$]0);}' < $1 > $1.t && mv -f $1.t $1 ;;
-esac])
+_fn_at_host_data_convert_line_endings $1])
 
 
 # LT_AT_UNIFY_NL(FILE, [RESULT-FILE])
-- 
2.16.0

